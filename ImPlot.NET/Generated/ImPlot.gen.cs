using System;
using SharpDX;
using System.Runtime.InteropServices;
using System.Text;
using ImGuiNET;

namespace ImPlotNET
{
    public static unsafe partial class ImPlot
    {
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotTime AddTime(ImPlotTime t, ImPlotTimeUnit unit, int count)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_AddTime(&__retval, t, unit, count);
            return __retval;
        }
        public static bool AllAxesInputLocked(ImPlotAxisPtr axes, int count)
        {
            ImPlotAxis* native_axes = axes.NativePtr;
            byte ret = ImPlotNative.ImPlot_AllAxesInputLocked(native_axes, count);
            return ret != 0;
        }
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte round = 0;
            ImPlotNative.ImPlot_Annotation_Bool(x, y, col, pix_offset, native_clamp, round);
        }
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, bool round)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_Annotation_Bool(x, y, col, pix_offset, native_clamp, native_round);
        }
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, string fmt)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_Annotation_Str(x, y, col, pix_offset, native_clamp, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static bool AnyAxesHeld(ImPlotAxisPtr axes, int count)
        {
            ImPlotAxis* native_axes = axes.NativePtr;
            byte ret = ImPlotNative.ImPlot_AnyAxesHeld(native_axes, count);
            return ret != 0;
        }
        public static bool AnyAxesHovered(ImPlotAxisPtr axes, int count)
        {
            ImPlotAxis* native_axes = axes.NativePtr;
            byte ret = ImPlotNative.ImPlot_AnyAxesHovered(native_axes, count);
            return ret != 0;
        }
        public static bool AnyAxesInputLocked(ImPlotAxisPtr axes, int count)
        {
            ImPlotAxis* native_axes = axes.NativePtr;
            byte ret = ImPlotNative.ImPlot_AnyAxesInputLocked(native_axes, count);
            return ret != 0;
        }
        public static bool BeginAlignedPlots(string group_id)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte vertical = 1;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
        public static bool BeginAlignedPlots(string group_id, bool vertical)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, native_vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceAxis(ImAxis axis)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceAxis(axis, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceAxis(ImAxis axis, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceAxis(axis, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id, ImGuiDragDropFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourcePlot()
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourcePlot(flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourcePlot(flags);
            return ret != 0;
        }
        public static bool BeginDragDropTargetAxis(ImAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetAxis(axis);
            return ret != 0;
        }
        public static bool BeginDragDropTargetLegend()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetLegend();
            return ret != 0;
        }
        public static bool BeginDragDropTargetPlot()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetPlot();
            return ret != 0;
        }
        public static bool BeginItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotItemFlags flags = (ImPlotItemFlags)0;
            ImPlotCol recolor_from = (ImPlotCol)(-1);
            byte ret = ImPlotNative.ImPlot_BeginItem(native_label_id, flags, recolor_from);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginItem(string label_id, ImPlotItemFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotCol recolor_from = (ImPlotCol)(-1);
            byte ret = ImPlotNative.ImPlot_BeginItem(native_label_id, flags, recolor_from);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginItem(string label_id, ImPlotItemFlags flags, ImPlotCol recolor_from)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginItem(native_label_id, flags, recolor_from);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiMouseButton mouse_button = (ImGuiMouseButton)1;
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id, ImGuiMouseButton mouse_button)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, Vector2 size, ImPlotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotSubplotFlags flags = (ImPlotSubplotFlags)0;
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* col_ratios = null;
            fixed (float* native_row_ratios = &row_ratios)
            {
                byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, col_ratios);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_title_id);
                }
                return ret != 0;
            }
        }
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios, ref float col_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            fixed (float* native_row_ratios = &row_ratios)
            {
                fixed (float* native_col_ratios = &col_ratios)
                {
                    byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, native_col_ratios);
                    if (title_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_title_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static void BustColorCache()
        {
            byte* native_plot_title_id = null;
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
        }
        public static void BustColorCache(string plot_title_id)
        {
            byte* native_plot_title_id;
            int plot_title_id_byteCount = 0;
            if (plot_title_id != null)
            {
                plot_title_id_byteCount = Encoding.UTF8.GetByteCount(plot_title_id);
                if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_plot_title_id = Util.Allocate(plot_title_id_byteCount + 1);
                }
                else
                {
                    byte* native_plot_title_id_stackBytes = stackalloc byte[plot_title_id_byteCount + 1];
                    native_plot_title_id = native_plot_title_id_stackBytes;
                }
                int native_plot_title_id_offset = Util.GetUtf8(plot_title_id, native_plot_title_id, plot_title_id_byteCount);
                native_plot_title_id[native_plot_title_id_offset] = 0;
            }
            else { native_plot_title_id = null; }
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
            if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_plot_title_id);
            }
        }
        public static void BustItemCache()
        {
            ImPlotNative.ImPlot_BustItemCache();
        }
        public static void BustPlotCache()
        {
            ImPlotNative.ImPlot_BustPlotCache();
        }
        public static uint CalcHoverColor(uint col)
        {
            uint ret = ImPlotNative.ImPlot_CalcHoverColor(col);
            return ret;
        }
        public static Vector2 CalcLegendSize(ImPlotItemGroupPtr items, Vector2 pad, Vector2 spacing, bool vertical)
        {
            Vector2 __retval;
            ImPlotItemGroup* native_items = items.NativePtr;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_CalcLegendSize(&__retval, native_items, pad, spacing, native_vertical);
            return __retval;
        }
        public static uint CalcTextColor(Vector4 bg)
        {
            uint ret = ImPlotNative.ImPlot_CalcTextColor_Vec4(bg);
            return ret;
        }
        public static uint CalcTextColor(uint bg)
        {
            uint ret = ImPlotNative.ImPlot_CalcTextColor_U32(bg);
            return ret;
        }
        public static Vector2 CalcTextSizeVertical(string text)
        {
            Vector2 __retval;
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotNative.ImPlot_CalcTextSizeVertical(&__retval, native_text);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
            return __retval;
        }
        public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (float* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_FloatPtr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (double* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_doublePtr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref sbyte values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (sbyte* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_S8Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref byte values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (byte* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_U8Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref short values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (short* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_S16Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (ushort* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_U16Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref int values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (int* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_S32Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref uint values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (uint* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_U32Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref long values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (long* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_S64Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CalculateBins(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int bins_out, ref double width_out)
        {
            fixed (ulong* native_values = &values)
            {
                fixed (int* native_bins_out = &bins_out)
                {
                    fixed (double* native_width_out = &width_out)
                    {
                        ImPlotNative.ImPlot_CalculateBins_U64Ptr(native_values, count, meth, range, native_bins_out, native_width_out);
                    }
                }
            }
        }
        public static void CancelPlotSelection()
        {
            ImPlotNative.ImPlot_CancelPlotSelection();
        }
        public static ImPlotTime CeilTime(ImPlotTime t, ImPlotTimeUnit unit)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_CeilTime(&__retval, t, unit);
            return __retval;
        }
        public static Vector2 ClampLabelPos(Vector2 pos, Vector2 size, Vector2 Min, Vector2 Max)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_ClampLabelPos(&__retval, pos, size, Min, Max);
            return __retval;
        }
        public static bool ClampLegendRect(ImRectPtr legend_rect, ImRect outer_rect, Vector2 pad)
        {
            ImRect* native_legend_rect = legend_rect.NativePtr;
            byte ret = ImPlotNative.ImPlot_ClampLegendRect(native_legend_rect, outer_rect, pad);
            return ret != 0;
        }
        public static bool ColormapButton(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ColormapButton(string label, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ColormapIcon(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_ColormapIcon(cmap);
        }
        public static void ColormapScale(string label, double scale_min, double scale_max)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format, ImPlotColormapScaleFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
        public static bool ColormapSlider(string label, ref float t)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector4* @out = null;
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, @out, native_format, cmap);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label);
                }
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_format);
                }
                return ret != 0;
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static ImPlotTime CombineDateTime(ImPlotTime date_part, ImPlotTime time_part)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_CombineDateTime(&__retval, date_part, time_part);
            return __retval;
        }
        public static IntPtr CreateContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_CreateContext();
            return ret;
        }
        public static void DestroyContext()
        {
            IntPtr ctx = IntPtr.Zero;
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static void DestroyContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static bool DragLineX(int id, ref double x, Vector4 col)
        {
            float thickness = 1;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness, ImPlotDragToolFlags flags)
        {
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, native_out_clicked, out_hovered, held);
                out_clicked = native_out_clicked_val != 0;
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, native_out_clicked, native_out_hovered, held);
                out_clicked = native_out_clicked_val != 0;
                out_hovered = native_out_hovered_val != 0;
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered, ref bool held)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte native_held_val = held ? (byte)1 : (byte)0;
            byte* native_held = &native_held_val;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags, native_out_clicked, native_out_hovered, native_held);
                out_clicked = native_out_clicked_val != 0;
                out_hovered = native_out_hovered_val != 0;
                held = native_held_val != 0;
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col)
        {
            float thickness = 1;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness, ImPlotDragToolFlags flags)
        {
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, out_clicked, out_hovered, held);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, native_out_clicked, out_hovered, held);
                out_clicked = native_out_clicked_val != 0;
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte* held = null;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, native_out_clicked, native_out_hovered, held);
                out_clicked = native_out_clicked_val != 0;
                out_hovered = native_out_hovered_val != 0;
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered, ref bool held)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte native_held_val = held ? (byte)1 : (byte)0;
            byte* native_held = &native_held_val;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags, native_out_clicked, native_out_hovered, native_held);
                out_clicked = native_out_clicked_val != 0;
                out_hovered = native_out_hovered_val != 0;
                held = native_held_val != 0;
                return ret != 0;
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col)
        {
            float size = 4;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, out_clicked, out_hovered, held);
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, out_clicked, out_hovered, held);
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size, ImPlotDragToolFlags flags)
        {
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, out_clicked, out_hovered, held);
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size, ImPlotDragToolFlags flags, ref bool out_clicked)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, native_out_clicked, out_hovered, held);
                    out_clicked = native_out_clicked_val != 0;
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte* held = null;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, native_out_clicked, native_out_hovered, held);
                    out_clicked = native_out_clicked_val != 0;
                    out_hovered = native_out_hovered_val != 0;
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered, ref bool held)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte native_held_val = held ? (byte)1 : (byte)0;
            byte* native_held = &native_held_val;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags, native_out_clicked, native_out_hovered, native_held);
                    out_clicked = native_out_clicked_val != 0;
                    out_hovered = native_out_hovered_val != 0;
                    held = native_held_val != 0;
                    return ret != 0;
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags, out_clicked, out_hovered, held);
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags)
        {
            byte* out_clicked = null;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags, out_clicked, out_hovered, held);
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags, ref bool out_clicked)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte* out_hovered = null;
            byte* held = null;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags, native_out_clicked, out_hovered, held);
                            out_clicked = native_out_clicked_val != 0;
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte* held = null;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags, native_out_clicked, native_out_hovered, held);
                            out_clicked = native_out_clicked_val != 0;
                            out_hovered = native_out_hovered_val != 0;
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags, ref bool out_clicked, ref bool out_hovered, ref bool held)
        {
            byte native_out_clicked_val = out_clicked ? (byte)1 : (byte)0;
            byte* native_out_clicked = &native_out_clicked_val;
            byte native_out_hovered_val = out_hovered ? (byte)1 : (byte)0;
            byte* native_out_hovered = &native_out_hovered_val;
            byte native_held_val = held ? (byte)1 : (byte)0;
            byte* native_held = &native_held_val;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags, native_out_clicked, native_out_hovered, native_held);
                            out_clicked = native_out_clicked_val != 0;
                            out_hovered = native_out_hovered_val != 0;
                            held = native_held_val != 0;
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static void EndAlignedPlots()
        {
            ImPlotNative.ImPlot_EndAlignedPlots();
        }
        public static void EndDragDropSource()
        {
            ImPlotNative.ImPlot_EndDragDropSource();
        }
        public static void EndDragDropTarget()
        {
            ImPlotNative.ImPlot_EndDragDropTarget();
        }
        public static void EndItem()
        {
            ImPlotNative.ImPlot_EndItem();
        }
        public static void EndLegendPopup()
        {
            ImPlotNative.ImPlot_EndLegendPopup();
        }
        public static void EndPlot()
        {
            ImPlotNative.ImPlot_EndPlot();
        }
        public static void EndSubplots()
        {
            ImPlotNative.ImPlot_EndSubplots();
        }
        public static void FillRange(ref ImVector buffer, int n, float vmin, float vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_Float_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, double vmin, double vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_double_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, sbyte vmin, sbyte vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_S8_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, byte vmin, byte vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_U8_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, short vmin, short vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_S16_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, ushort vmin, ushort vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_U16_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, int vmin, int vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_S32_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, uint vmin, uint vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_U32_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, long vmin, long vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_S64_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FillRange(ref ImVector buffer, int n, ulong vmin, ulong vmax)
        {
            fixed (ImVector* native_buffer = &buffer)
            {
                ImPlotNative.ImPlot_FillRange_Vector_U64_Ptr(native_buffer, n, vmin, vmax);
            }
        }
        public static void FitPoint(ImPlotPoint p)
        {
            ImPlotNative.ImPlot_FitPoint(p);
        }
        public static void FitPointX(double x)
        {
            ImPlotNative.ImPlot_FitPointX(x);
        }
        public static void FitPointY(double y)
        {
            ImPlotNative.ImPlot_FitPointY(y);
        }
        public static bool FitThisFrame()
        {
            byte ret = ImPlotNative.ImPlot_FitThisFrame();
            return ret != 0;
        }
        public static ImPlotTime FloorTime(ImPlotTime t, ImPlotTimeUnit unit)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_FloorTime(&__retval, t, unit);
            return __retval;
        }
        public static int FormatDate(ImPlotTime t, string buffer, int size, ImPlotDateFmt fmt, bool use_iso_8601)
        {
            byte* native_buffer;
            int buffer_byteCount = 0;
            if (buffer != null)
            {
                buffer_byteCount = Encoding.UTF8.GetByteCount(buffer);
                if (buffer_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buffer = Util.Allocate(buffer_byteCount + 1);
                }
                else
                {
                    byte* native_buffer_stackBytes = stackalloc byte[buffer_byteCount + 1];
                    native_buffer = native_buffer_stackBytes;
                }
                int native_buffer_offset = Util.GetUtf8(buffer, native_buffer, buffer_byteCount);
                native_buffer[native_buffer_offset] = 0;
            }
            else { native_buffer = null; }
            byte native_use_iso_8601 = use_iso_8601 ? (byte)1 : (byte)0;
            int ret = ImPlotNative.ImPlot_FormatDate(t, native_buffer, size, fmt, native_use_iso_8601);
            if (buffer_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buffer);
            }
            return ret;
        }
        public static int FormatDateTime(ImPlotTime t, string buffer, int size, ImPlotDateTimeSpec fmt)
        {
            byte* native_buffer;
            int buffer_byteCount = 0;
            if (buffer != null)
            {
                buffer_byteCount = Encoding.UTF8.GetByteCount(buffer);
                if (buffer_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buffer = Util.Allocate(buffer_byteCount + 1);
                }
                else
                {
                    byte* native_buffer_stackBytes = stackalloc byte[buffer_byteCount + 1];
                    native_buffer = native_buffer_stackBytes;
                }
                int native_buffer_offset = Util.GetUtf8(buffer, native_buffer, buffer_byteCount);
                native_buffer[native_buffer_offset] = 0;
            }
            else { native_buffer = null; }
            int ret = ImPlotNative.ImPlot_FormatDateTime(t, native_buffer, size, fmt);
            if (buffer_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buffer);
            }
            return ret;
        }
        public static int Formatter_Default(double value, string buff, int size, IntPtr data)
        {
            byte* native_buff;
            int buff_byteCount = 0;
            if (buff != null)
            {
                buff_byteCount = Encoding.UTF8.GetByteCount(buff);
                if (buff_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buff = Util.Allocate(buff_byteCount + 1);
                }
                else
                {
                    byte* native_buff_stackBytes = stackalloc byte[buff_byteCount + 1];
                    native_buff = native_buff_stackBytes;
                }
                int native_buff_offset = Util.GetUtf8(buff, native_buff, buff_byteCount);
                native_buff[native_buff_offset] = 0;
            }
            else { native_buff = null; }
            void* native_data = (void*)data.ToPointer();
            int ret = ImPlotNative.ImPlot_Formatter_Default(value, native_buff, size, native_data);
            if (buff_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buff);
            }
            return ret;
        }
        public static int Formatter_Logit(double value, string buff, int size, IntPtr noname1)
        {
            byte* native_buff;
            int buff_byteCount = 0;
            if (buff != null)
            {
                buff_byteCount = Encoding.UTF8.GetByteCount(buff);
                if (buff_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buff = Util.Allocate(buff_byteCount + 1);
                }
                else
                {
                    byte* native_buff_stackBytes = stackalloc byte[buff_byteCount + 1];
                    native_buff = native_buff_stackBytes;
                }
                int native_buff_offset = Util.GetUtf8(buff, native_buff, buff_byteCount);
                native_buff[native_buff_offset] = 0;
            }
            else { native_buff = null; }
            void* native_noname1 = (void*)noname1.ToPointer();
            int ret = ImPlotNative.ImPlot_Formatter_Logit(value, native_buff, size, native_noname1);
            if (buff_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buff);
            }
            return ret;
        }
        public static int Formatter_Time(double noname1, string buff, int size, IntPtr data)
        {
            byte* native_buff;
            int buff_byteCount = 0;
            if (buff != null)
            {
                buff_byteCount = Encoding.UTF8.GetByteCount(buff);
                if (buff_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buff = Util.Allocate(buff_byteCount + 1);
                }
                else
                {
                    byte* native_buff_stackBytes = stackalloc byte[buff_byteCount + 1];
                    native_buff = native_buff_stackBytes;
                }
                int native_buff_offset = Util.GetUtf8(buff, native_buff, buff_byteCount);
                native_buff[native_buff_offset] = 0;
            }
            else { native_buff = null; }
            void* native_data = (void*)data.ToPointer();
            int ret = ImPlotNative.ImPlot_Formatter_Time(noname1, native_buff, size, native_data);
            if (buff_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buff);
            }
            return ret;
        }
        public static int FormatTime(ImPlotTime t, string buffer, int size, ImPlotTimeFmt fmt, bool use_24_hr_clk)
        {
            byte* native_buffer;
            int buffer_byteCount = 0;
            if (buffer != null)
            {
                buffer_byteCount = Encoding.UTF8.GetByteCount(buffer);
                if (buffer_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buffer = Util.Allocate(buffer_byteCount + 1);
                }
                else
                {
                    byte* native_buffer_stackBytes = stackalloc byte[buffer_byteCount + 1];
                    native_buffer = native_buffer_stackBytes;
                }
                int native_buffer_offset = Util.GetUtf8(buffer, native_buffer, buffer_byteCount);
                native_buffer[native_buffer_offset] = 0;
            }
            else { native_buffer = null; }
            byte native_use_24_hr_clk = use_24_hr_clk ? (byte)1 : (byte)0;
            int ret = ImPlotNative.ImPlot_FormatTime(t, native_buffer, size, fmt, native_use_24_hr_clk);
            if (buffer_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buffer);
            }
            return ret;
        }
        public static Vector4 GetAutoColor(ImPlotCol idx)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetAutoColor(&__retval, idx);
            return __retval;
        }
        public static Vector4 GetColormapColor(int idx)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static Vector4 GetColormapColor(int idx, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static uint GetColormapColorU32(int idx, ImPlotColormap cmap)
        {
            uint ret = ImPlotNative.ImPlot_GetColormapColorU32(idx, cmap);
            return ret;
        }
        public static int GetColormapCount()
        {
            int ret = ImPlotNative.ImPlot_GetColormapCount();
            return ret;
        }
        public static ImPlotColormap GetColormapIndex(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotColormap ret = ImPlotNative.ImPlot_GetColormapIndex(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
            return ret;
        }
        public static string GetColormapName(ImPlotColormap cmap)
        {
            byte* ret = ImPlotNative.ImPlot_GetColormapName(cmap);
            return Util.StringFromPtr(ret);
        }
        public static int GetColormapSize()
        {
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static int GetColormapSize(ImPlotColormap cmap)
        {
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static IntPtr GetCurrentContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_GetCurrentContext();
            return ret;
        }
        public static ImPlotItemPtr GetCurrentItem()
        {
            ImPlotItem* ret = ImPlotNative.ImPlot_GetCurrentItem();
            return new ImPlotItemPtr(ret);
        }
        public static ImPlotPlotPtr GetCurrentPlot()
        {
            ImPlotPlot* ret = ImPlotNative.ImPlot_GetCurrentPlot();
            return new ImPlotPlotPtr(ret);
        }
        public static int GetDaysInMonth(int year, int month)
        {
            int ret = ImPlotNative.ImPlot_GetDaysInMonth(year, month);
            return ret;
        }
        public static Time* GetGmtTime(ImPlotTime t, ref Time ptm)
        {
            fixed (Time* native_ptm = &ptm)
            {
                Time* ret = ImPlotNative.ImPlot_GetGmtTime(t, native_ptm);
                return ret;
            }
        }
        public static ImPlotInputMapPtr GetInputMap()
        {
            ImPlotInputMap* ret = ImPlotNative.ImPlot_GetInputMap();
            return new ImPlotInputMapPtr(ret);
        }
        public static ImPlotItemPtr GetItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotItem* ret = ImPlotNative.ImPlot_GetItem(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return new ImPlotItemPtr(ret);
        }
        public static ImPlotNextItemDataPtr GetItemData()
        {
            ImPlotNextItemData* ret = ImPlotNative.ImPlot_GetItemData();
            return new ImPlotNextItemDataPtr(ret);
        }
        public static Vector4 GetLastItemColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetLastItemColor(&__retval);
            return __retval;
        }
        public static Vector2 GetLocationPos(ImRect outer_rect, Vector2 inner_size, ImPlotLocation location)
        {
            Vector2 __retval;
            Vector2 pad = new Vector2();
            ImPlotNative.ImPlot_GetLocationPos(&__retval, outer_rect, inner_size, location, pad);
            return __retval;
        }
        public static Vector2 GetLocationPos(ImRect outer_rect, Vector2 inner_size, ImPlotLocation location, Vector2 pad)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetLocationPos(&__retval, outer_rect, inner_size, location, pad);
            return __retval;
        }
        public static Time* GetLocTime(ImPlotTime t, ref Time ptm)
        {
            fixed (Time* native_ptm = &ptm)
            {
                Time* ret = ImPlotNative.ImPlot_GetLocTime(t, native_ptm);
                return ret;
            }
        }
        public static string GetMarkerName(ImPlotMarker idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetMarkerName(idx);
            return Util.StringFromPtr(ret);
        }
        public static int GetMonth(ImPlotTime t)
        {
            int ret = ImPlotNative.ImPlot_GetMonth(t);
            return ret;
        }
        public static ImPlotPlotPtr GetPlot(string title)
        {
            byte* native_title;
            int title_byteCount = 0;
            if (title != null)
            {
                title_byteCount = Encoding.UTF8.GetByteCount(title);
                if (title_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title = Util.Allocate(title_byteCount + 1);
                }
                else
                {
                    byte* native_title_stackBytes = stackalloc byte[title_byteCount + 1];
                    native_title = native_title_stackBytes;
                }
                int native_title_offset = Util.GetUtf8(title, native_title, title_byteCount);
                native_title[native_title_offset] = 0;
            }
            else { native_title = null; }
            ImPlotPlot* ret = ImPlotNative.ImPlot_GetPlot(native_title);
            if (title_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title);
            }
            return new ImPlotPlotPtr(ret);
        }
        public static ImDrawListPtr GetPlotDrawList()
        {
            ImDrawList* ret = ImPlotNative.ImPlot_GetPlotDrawList();
            return new ImDrawListPtr(ret);
        }
        public static ImPlotRect GetPlotLimits()
        {
            ImPlotRect __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotRect GetPlotLimits(ImAxis x_axis)
        {
            ImPlotRect __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotRect GetPlotLimits(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotRect __retval;
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos()
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotPos()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotPos(&__retval);
            return __retval;
        }
        public static ImPlotRect GetPlotSelection()
        {
            ImPlotRect __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotSelection(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotRect GetPlotSelection(ImAxis x_axis)
        {
            ImPlotRect __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotSelection(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotRect GetPlotSelection(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotRect __retval;
            ImPlotNative.ImPlot_GetPlotSelection(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotSize()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotSize(&__retval);
            return __retval;
        }
        public static ImPlotStylePtr GetStyle()
        {
            ImPlotStyle* ret = ImPlotNative.ImPlot_GetStyle();
            return new ImPlotStylePtr(ret);
        }
        public static string GetStyleColorName(ImPlotCol idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetStyleColorName(idx);
            return Util.StringFromPtr(ret);
        }
        public static uint GetStyleColorU32(ImPlotCol idx)
        {
            uint ret = ImPlotNative.ImPlot_GetStyleColorU32(idx);
            return ret;
        }
        public static Vector4 GetStyleColorVec4(ImPlotCol idx)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetStyleColorVec4(&__retval, idx);
            return __retval;
        }
        public static Time* GetTime(ImPlotTime t, ref Time ptm)
        {
            fixed (Time* native_ptm = &ptm)
            {
                Time* ret = ImPlotNative.ImPlot_GetTime(t, native_ptm);
                return ret;
            }
        }
        public static int GetYear(ImPlotTime t)
        {
            int ret = ImPlotNative.ImPlot_GetYear(t);
            return ret;
        }
        public static void HideNextItem()
        {
            byte hidden = 1;
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_HideNextItem(hidden, cond);
        }
        public static void HideNextItem(bool hidden)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static void HideNextItem(bool hidden, ImPlotCond cond)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static bool ImAlmostEqual(double v1, double v2)
        {
            int ulp = 2;
            byte ret = ImPlotNative.ImPlot_ImAlmostEqual(v1, v2, ulp);
            return ret != 0;
        }
        public static bool ImAlmostEqual(double v1, double v2, int ulp)
        {
            byte ret = ImPlotNative.ImPlot_ImAlmostEqual(v1, v2, ulp);
            return ret != 0;
        }
        public static uint ImAlphaU32(uint col, float alpha)
        {
            uint ret = ImPlotNative.ImPlot_ImAlphaU32(col, alpha);
            return ret;
        }
        public static float ImAsinh(float x)
        {
            float ret = ImPlotNative.ImPlot_ImAsinh_Float(x);
            return ret;
        }
        public static double ImAsinh(double x)
        {
            double ret = ImPlotNative.ImPlot_ImAsinh_double(x);
            return ret;
        }
        public static double ImConstrainInf(double val)
        {
            double ret = ImPlotNative.ImPlot_ImConstrainInf(val);
            return ret;
        }
        public static double ImConstrainLog(double val)
        {
            double ret = ImPlotNative.ImPlot_ImConstrainLog(val);
            return ret;
        }
        public static double ImConstrainNan(double val)
        {
            double ret = ImPlotNative.ImPlot_ImConstrainNan(val);
            return ret;
        }
        public static double ImConstrainTime(double val)
        {
            double ret = ImPlotNative.ImPlot_ImConstrainTime(val);
            return ret;
        }
        public static uint ImLerpU32(ref uint colors, int size, float t)
        {
            fixed (uint* native_colors = &colors)
            {
                uint ret = ImPlotNative.ImPlot_ImLerpU32(native_colors, size, t);
                return ret;
            }
        }
        public static float ImLog10(float x)
        {
            float ret = ImPlotNative.ImPlot_ImLog10_Float(x);
            return ret;
        }
        public static double ImLog10(double x)
        {
            double ret = ImPlotNative.ImPlot_ImLog10_double(x);
            return ret;
        }
        public static float ImMaxArray(ref float values, int count)
        {
            fixed (float* native_values = &values)
            {
                float ret = ImPlotNative.ImPlot_ImMaxArray_FloatPtr(native_values, count);
                return ret;
            }
        }
        public static double ImMaxArray(ref double values, int count)
        {
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMaxArray_doublePtr(native_values, count);
                return ret;
            }
        }
        public static sbyte ImMaxArray(ref sbyte values, int count)
        {
            fixed (sbyte* native_values = &values)
            {
                sbyte ret = ImPlotNative.ImPlot_ImMaxArray_S8Ptr(native_values, count);
                return ret;
            }
        }
        public static byte ImMaxArray(ref byte values, int count)
        {
            fixed (byte* native_values = &values)
            {
                byte ret = ImPlotNative.ImPlot_ImMaxArray_U8Ptr(native_values, count);
                return ret;
            }
        }
        public static short ImMaxArray(ref short values, int count)
        {
            fixed (short* native_values = &values)
            {
                short ret = ImPlotNative.ImPlot_ImMaxArray_S16Ptr(native_values, count);
                return ret;
            }
        }
        public static ushort ImMaxArray(ref ushort values, int count)
        {
            fixed (ushort* native_values = &values)
            {
                ushort ret = ImPlotNative.ImPlot_ImMaxArray_U16Ptr(native_values, count);
                return ret;
            }
        }
        public static int ImMaxArray(ref int values, int count)
        {
            fixed (int* native_values = &values)
            {
                int ret = ImPlotNative.ImPlot_ImMaxArray_S32Ptr(native_values, count);
                return ret;
            }
        }
        public static uint ImMaxArray(ref uint values, int count)
        {
            fixed (uint* native_values = &values)
            {
                uint ret = ImPlotNative.ImPlot_ImMaxArray_U32Ptr(native_values, count);
                return ret;
            }
        }
        public static long ImMaxArray(ref long values, int count)
        {
            fixed (long* native_values = &values)
            {
                long ret = ImPlotNative.ImPlot_ImMaxArray_S64Ptr(native_values, count);
                return ret;
            }
        }
        public static ulong ImMaxArray(ref ulong values, int count)
        {
            fixed (ulong* native_values = &values)
            {
                ulong ret = ImPlotNative.ImPlot_ImMaxArray_U64Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref float values, int count)
        {
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_FloatPtr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref double values, int count)
        {
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_doublePtr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref sbyte values, int count)
        {
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_S8Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref byte values, int count)
        {
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_U8Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref short values, int count)
        {
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_S16Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref ushort values, int count)
        {
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_U16Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref int values, int count)
        {
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_S32Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref uint values, int count)
        {
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_U32Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref long values, int count)
        {
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_S64Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImMean(ref ulong values, int count)
        {
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMean_U64Ptr(native_values, count);
                return ret;
            }
        }
        public static float ImMinArray(ref float values, int count)
        {
            fixed (float* native_values = &values)
            {
                float ret = ImPlotNative.ImPlot_ImMinArray_FloatPtr(native_values, count);
                return ret;
            }
        }
        public static double ImMinArray(ref double values, int count)
        {
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImMinArray_doublePtr(native_values, count);
                return ret;
            }
        }
        public static sbyte ImMinArray(ref sbyte values, int count)
        {
            fixed (sbyte* native_values = &values)
            {
                sbyte ret = ImPlotNative.ImPlot_ImMinArray_S8Ptr(native_values, count);
                return ret;
            }
        }
        public static byte ImMinArray(ref byte values, int count)
        {
            fixed (byte* native_values = &values)
            {
                byte ret = ImPlotNative.ImPlot_ImMinArray_U8Ptr(native_values, count);
                return ret;
            }
        }
        public static short ImMinArray(ref short values, int count)
        {
            fixed (short* native_values = &values)
            {
                short ret = ImPlotNative.ImPlot_ImMinArray_S16Ptr(native_values, count);
                return ret;
            }
        }
        public static ushort ImMinArray(ref ushort values, int count)
        {
            fixed (ushort* native_values = &values)
            {
                ushort ret = ImPlotNative.ImPlot_ImMinArray_U16Ptr(native_values, count);
                return ret;
            }
        }
        public static int ImMinArray(ref int values, int count)
        {
            fixed (int* native_values = &values)
            {
                int ret = ImPlotNative.ImPlot_ImMinArray_S32Ptr(native_values, count);
                return ret;
            }
        }
        public static uint ImMinArray(ref uint values, int count)
        {
            fixed (uint* native_values = &values)
            {
                uint ret = ImPlotNative.ImPlot_ImMinArray_U32Ptr(native_values, count);
                return ret;
            }
        }
        public static long ImMinArray(ref long values, int count)
        {
            fixed (long* native_values = &values)
            {
                long ret = ImPlotNative.ImPlot_ImMinArray_S64Ptr(native_values, count);
                return ret;
            }
        }
        public static ulong ImMinArray(ref ulong values, int count)
        {
            fixed (ulong* native_values = &values)
            {
                ulong ret = ImPlotNative.ImPlot_ImMinArray_U64Ptr(native_values, count);
                return ret;
            }
        }
        public static void ImMinMaxArray(ref float values, int count, ref float min_out, ref float max_out)
        {
            fixed (float* native_values = &values)
            {
                fixed (float* native_min_out = &min_out)
                {
                    fixed (float* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_FloatPtr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref double values, int count, ref double min_out, ref double max_out)
        {
            fixed (double* native_values = &values)
            {
                fixed (double* native_min_out = &min_out)
                {
                    fixed (double* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_doublePtr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref sbyte values, int count, ref sbyte min_out, ref sbyte max_out)
        {
            fixed (sbyte* native_values = &values)
            {
                fixed (sbyte* native_min_out = &min_out)
                {
                    fixed (sbyte* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_S8Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref byte values, int count, ref byte min_out, ref byte max_out)
        {
            fixed (byte* native_values = &values)
            {
                fixed (byte* native_min_out = &min_out)
                {
                    fixed (byte* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_U8Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref short values, int count, ref short min_out, ref short max_out)
        {
            fixed (short* native_values = &values)
            {
                fixed (short* native_min_out = &min_out)
                {
                    fixed (short* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_S16Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref ushort values, int count, ref ushort min_out, ref ushort max_out)
        {
            fixed (ushort* native_values = &values)
            {
                fixed (ushort* native_min_out = &min_out)
                {
                    fixed (ushort* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_U16Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref int values, int count, ref int min_out, ref int max_out)
        {
            fixed (int* native_values = &values)
            {
                fixed (int* native_min_out = &min_out)
                {
                    fixed (int* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_S32Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref uint values, int count, ref uint min_out, ref uint max_out)
        {
            fixed (uint* native_values = &values)
            {
                fixed (uint* native_min_out = &min_out)
                {
                    fixed (uint* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_U32Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref long values, int count, ref long min_out, ref long max_out)
        {
            fixed (long* native_values = &values)
            {
                fixed (long* native_min_out = &min_out)
                {
                    fixed (long* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_S64Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static void ImMinMaxArray(ref ulong values, int count, ref ulong min_out, ref ulong max_out)
        {
            fixed (ulong* native_values = &values)
            {
                fixed (ulong* native_min_out = &min_out)
                {
                    fixed (ulong* native_max_out = &max_out)
                    {
                        ImPlotNative.ImPlot_ImMinMaxArray_U64Ptr(native_values, count, native_min_out, native_max_out);
                    }
                }
            }
        }
        public static uint ImMixU32(uint a, uint b, uint s)
        {
            uint ret = ImPlotNative.ImPlot_ImMixU32(a, b, s);
            return ret;
        }
        public static bool ImNan(double val)
        {
            byte ret = ImPlotNative.ImPlot_ImNan(val);
            return ret != 0;
        }
        public static bool ImNanOrInf(double val)
        {
            byte ret = ImPlotNative.ImPlot_ImNanOrInf(val);
            return ret != 0;
        }
        public static bool ImOverlaps(float min_a, float max_a, float min_b, float max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_Float(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(double min_a, double max_a, double min_b, double max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_double(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(sbyte min_a, sbyte max_a, sbyte min_b, sbyte max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_S8(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(byte min_a, byte max_a, byte min_b, byte max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_U8(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(short min_a, short max_a, short min_b, short max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_S16(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(ushort min_a, ushort max_a, ushort min_b, ushort max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_U16(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(int min_a, int max_a, int min_b, int max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_S32(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(uint min_a, uint max_a, uint min_b, uint max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_U32(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(long min_a, long max_a, long min_b, long max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_S64(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static bool ImOverlaps(ulong min_a, ulong max_a, ulong min_b, ulong max_b)
        {
            byte ret = ImPlotNative.ImPlot_ImOverlaps_U64(min_a, max_a, min_b, max_b);
            return ret != 0;
        }
        public static int ImPosMod(int l, int r)
        {
            int ret = ImPlotNative.ImPlot_ImPosMod(l, r);
            return ret;
        }
        public static float ImRemap(float x, float x0, float x1, float y0, float y1)
        {
            float ret = ImPlotNative.ImPlot_ImRemap_Float(x, x0, x1, y0, y1);
            return ret;
        }
        public static double ImRemap(double x, double x0, double x1, double y0, double y1)
        {
            double ret = ImPlotNative.ImPlot_ImRemap_double(x, x0, x1, y0, y1);
            return ret;
        }
        public static sbyte ImRemap(sbyte x, sbyte x0, sbyte x1, sbyte y0, sbyte y1)
        {
            sbyte ret = ImPlotNative.ImPlot_ImRemap_S8(x, x0, x1, y0, y1);
            return ret;
        }
        public static byte ImRemap(byte x, byte x0, byte x1, byte y0, byte y1)
        {
            byte ret = ImPlotNative.ImPlot_ImRemap_U8(x, x0, x1, y0, y1);
            return ret;
        }
        public static short ImRemap(short x, short x0, short x1, short y0, short y1)
        {
            short ret = ImPlotNative.ImPlot_ImRemap_S16(x, x0, x1, y0, y1);
            return ret;
        }
        public static ushort ImRemap(ushort x, ushort x0, ushort x1, ushort y0, ushort y1)
        {
            ushort ret = ImPlotNative.ImPlot_ImRemap_U16(x, x0, x1, y0, y1);
            return ret;
        }
        public static int ImRemap(int x, int x0, int x1, int y0, int y1)
        {
            int ret = ImPlotNative.ImPlot_ImRemap_S32(x, x0, x1, y0, y1);
            return ret;
        }
        public static uint ImRemap(uint x, uint x0, uint x1, uint y0, uint y1)
        {
            uint ret = ImPlotNative.ImPlot_ImRemap_U32(x, x0, x1, y0, y1);
            return ret;
        }
        public static long ImRemap(long x, long x0, long x1, long y0, long y1)
        {
            long ret = ImPlotNative.ImPlot_ImRemap_S64(x, x0, x1, y0, y1);
            return ret;
        }
        public static ulong ImRemap(ulong x, ulong x0, ulong x1, ulong y0, ulong y1)
        {
            ulong ret = ImPlotNative.ImPlot_ImRemap_U64(x, x0, x1, y0, y1);
            return ret;
        }
        public static float ImRemap01(float x, float x0, float x1)
        {
            float ret = ImPlotNative.ImPlot_ImRemap01_Float(x, x0, x1);
            return ret;
        }
        public static double ImRemap01(double x, double x0, double x1)
        {
            double ret = ImPlotNative.ImPlot_ImRemap01_double(x, x0, x1);
            return ret;
        }
        public static sbyte ImRemap01(sbyte x, sbyte x0, sbyte x1)
        {
            sbyte ret = ImPlotNative.ImPlot_ImRemap01_S8(x, x0, x1);
            return ret;
        }
        public static byte ImRemap01(byte x, byte x0, byte x1)
        {
            byte ret = ImPlotNative.ImPlot_ImRemap01_U8(x, x0, x1);
            return ret;
        }
        public static short ImRemap01(short x, short x0, short x1)
        {
            short ret = ImPlotNative.ImPlot_ImRemap01_S16(x, x0, x1);
            return ret;
        }
        public static ushort ImRemap01(ushort x, ushort x0, ushort x1)
        {
            ushort ret = ImPlotNative.ImPlot_ImRemap01_U16(x, x0, x1);
            return ret;
        }
        public static int ImRemap01(int x, int x0, int x1)
        {
            int ret = ImPlotNative.ImPlot_ImRemap01_S32(x, x0, x1);
            return ret;
        }
        public static uint ImRemap01(uint x, uint x0, uint x1)
        {
            uint ret = ImPlotNative.ImPlot_ImRemap01_U32(x, x0, x1);
            return ret;
        }
        public static long ImRemap01(long x, long x0, long x1)
        {
            long ret = ImPlotNative.ImPlot_ImRemap01_S64(x, x0, x1);
            return ret;
        }
        public static ulong ImRemap01(ulong x, ulong x0, ulong x1)
        {
            ulong ret = ImPlotNative.ImPlot_ImRemap01_U64(x, x0, x1);
            return ret;
        }
        public static float ImSinh(float x)
        {
            float ret = ImPlotNative.ImPlot_ImSinh_Float(x);
            return ret;
        }
        public static double ImSinh(double x)
        {
            double ret = ImPlotNative.ImPlot_ImSinh_double(x);
            return ret;
        }
        public static double ImStdDev(ref float values, int count)
        {
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_FloatPtr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref double values, int count)
        {
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_doublePtr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref sbyte values, int count)
        {
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_S8Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref byte values, int count)
        {
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_U8Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref short values, int count)
        {
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_S16Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref ushort values, int count)
        {
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_U16Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref int values, int count)
        {
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_S32Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref uint values, int count)
        {
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_U32Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref long values, int count)
        {
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_S64Ptr(native_values, count);
                return ret;
            }
        }
        public static double ImStdDev(ref ulong values, int count)
        {
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImStdDev_U64Ptr(native_values, count);
                return ret;
            }
        }
        public static float ImSum(ref float values, int count)
        {
            fixed (float* native_values = &values)
            {
                float ret = ImPlotNative.ImPlot_ImSum_FloatPtr(native_values, count);
                return ret;
            }
        }
        public static double ImSum(ref double values, int count)
        {
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_ImSum_doublePtr(native_values, count);
                return ret;
            }
        }
        public static sbyte ImSum(ref sbyte values, int count)
        {
            fixed (sbyte* native_values = &values)
            {
                sbyte ret = ImPlotNative.ImPlot_ImSum_S8Ptr(native_values, count);
                return ret;
            }
        }
        public static byte ImSum(ref byte values, int count)
        {
            fixed (byte* native_values = &values)
            {
                byte ret = ImPlotNative.ImPlot_ImSum_U8Ptr(native_values, count);
                return ret;
            }
        }
        public static short ImSum(ref short values, int count)
        {
            fixed (short* native_values = &values)
            {
                short ret = ImPlotNative.ImPlot_ImSum_S16Ptr(native_values, count);
                return ret;
            }
        }
        public static ushort ImSum(ref ushort values, int count)
        {
            fixed (ushort* native_values = &values)
            {
                ushort ret = ImPlotNative.ImPlot_ImSum_U16Ptr(native_values, count);
                return ret;
            }
        }
        public static int ImSum(ref int values, int count)
        {
            fixed (int* native_values = &values)
            {
                int ret = ImPlotNative.ImPlot_ImSum_S32Ptr(native_values, count);
                return ret;
            }
        }
        public static uint ImSum(ref uint values, int count)
        {
            fixed (uint* native_values = &values)
            {
                uint ret = ImPlotNative.ImPlot_ImSum_U32Ptr(native_values, count);
                return ret;
            }
        }
        public static long ImSum(ref long values, int count)
        {
            fixed (long* native_values = &values)
            {
                long ret = ImPlotNative.ImPlot_ImSum_S64Ptr(native_values, count);
                return ret;
            }
        }
        public static ulong ImSum(ref ulong values, int count)
        {
            fixed (ulong* native_values = &values)
            {
                ulong ret = ImPlotNative.ImPlot_ImSum_U64Ptr(native_values, count);
                return ret;
            }
        }
        public static void Initialize(IntPtr ctx)
        {
            ImPlotNative.ImPlot_Initialize(ctx);
        }
        public static Vector2 Intersection(Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_Intersection(&__retval, a1, a2, b1, b2);
            return __retval;
        }
        public static bool IsAxisHovered(ImAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_IsAxisHovered(axis);
            return ret != 0;
        }
        public static bool IsColorAuto(Vector4 col)
        {
            byte ret = ImPlotNative.ImPlot_IsColorAuto_Vec4(col);
            return ret != 0;
        }
        public static bool IsColorAuto(ImPlotCol idx)
        {
            byte ret = ImPlotNative.ImPlot_IsColorAuto_PlotCol(idx);
            return ret != 0;
        }
        public static bool IsLeapYear(int year)
        {
            byte ret = ImPlotNative.ImPlot_IsLeapYear(year);
            return ret != 0;
        }
        public static bool IsLegendEntryHovered(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_IsLegendEntryHovered(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool IsPlotHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotHovered();
            return ret != 0;
        }
        public static bool IsPlotSelected()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotSelected();
            return ret != 0;
        }
        public static bool IsSubplotsHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsSubplotsHovered();
            return ret != 0;
        }
        public static void ItemIcon(Vector4 col)
        {
            ImPlotNative.ImPlot_ItemIcon_Vec4(col);
        }
        public static void ItemIcon(uint col)
        {
            ImPlotNative.ImPlot_ItemIcon_U32(col);
        }
        public static void LabelAxisValue(ImPlotAxis axis, double value, string buff, int size)
        {
            byte* native_buff;
            int buff_byteCount = 0;
            if (buff != null)
            {
                buff_byteCount = Encoding.UTF8.GetByteCount(buff);
                if (buff_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buff = Util.Allocate(buff_byteCount + 1);
                }
                else
                {
                    byte* native_buff_stackBytes = stackalloc byte[buff_byteCount + 1];
                    native_buff = native_buff_stackBytes;
                }
                int native_buff_offset = Util.GetUtf8(buff, native_buff, buff_byteCount);
                native_buff[native_buff_offset] = 0;
            }
            else { native_buff = null; }
            byte round = 0;
            ImPlotNative.ImPlot_LabelAxisValue(axis, value, native_buff, size, round);
            if (buff_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buff);
            }
        }
        public static void LabelAxisValue(ImPlotAxis axis, double value, string buff, int size, bool round)
        {
            byte* native_buff;
            int buff_byteCount = 0;
            if (buff != null)
            {
                buff_byteCount = Encoding.UTF8.GetByteCount(buff);
                if (buff_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_buff = Util.Allocate(buff_byteCount + 1);
                }
                else
                {
                    byte* native_buff_stackBytes = stackalloc byte[buff_byteCount + 1];
                    native_buff = native_buff_stackBytes;
                }
                int native_buff_offset = Util.GetUtf8(buff, native_buff, buff_byteCount);
                native_buff[native_buff_offset] = 0;
            }
            else { native_buff = null; }
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_LabelAxisValue(axis, value, native_buff, size, native_round);
            if (buff_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_buff);
            }
        }
        public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, IntPtr formatter_data)
        {
            ImPlotTicker* native_ticker = ticker.NativePtr;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            void* native_formatter_data = (void*)formatter_data.ToPointer();
            ImPlotNative.ImPlot_Locator_Default(native_ticker, range, pixels, native_vertical, formatter, native_formatter_data);
        }
        public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, IntPtr formatter_data)
        {
            ImPlotTicker* native_ticker = ticker.NativePtr;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            void* native_formatter_data = (void*)formatter_data.ToPointer();
            ImPlotNative.ImPlot_Locator_Log10(native_ticker, range, pixels, native_vertical, formatter, native_formatter_data);
        }
        public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, IntPtr formatter_data)
        {
            ImPlotTicker* native_ticker = ticker.NativePtr;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            void* native_formatter_data = (void*)formatter_data.ToPointer();
            ImPlotNative.ImPlot_Locator_SymLog(native_ticker, range, pixels, native_vertical, formatter, native_formatter_data);
        }
        public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, IntPtr formatter_data)
        {
            ImPlotTicker* native_ticker = ticker.NativePtr;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            void* native_formatter_data = (void*)formatter_data.ToPointer();
            ImPlotNative.ImPlot_Locator_Time(native_ticker, range, pixels, native_vertical, formatter, native_formatter_data);
        }
        public static ImPlotTime MakeTime(int year)
        {
            ImPlotTime __retval;
            int month = 0;
            int day = 1;
            int hour = 0;
            int min = 0;
            int sec = 0;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month)
        {
            ImPlotTime __retval;
            int day = 1;
            int hour = 0;
            int min = 0;
            int sec = 0;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month, int day)
        {
            ImPlotTime __retval;
            int hour = 0;
            int min = 0;
            int sec = 0;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month, int day, int hour)
        {
            ImPlotTime __retval;
            int min = 0;
            int sec = 0;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min)
        {
            ImPlotTime __retval;
            int sec = 0;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec)
        {
            ImPlotTime __retval;
            int us = 0;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec, int us)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_MakeTime(&__retval, year, month, day, hour, min, sec, us);
            return __retval;
        }
        public static void MapInputDefault()
        {
            ImPlotInputMap* dst = null;
            ImPlotNative.ImPlot_MapInputDefault(dst);
        }
        public static void MapInputDefault(ImPlotInputMapPtr dst)
        {
            ImPlotInputMap* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_MapInputDefault(native_dst);
        }
        public static void MapInputReverse()
        {
            ImPlotInputMap* dst = null;
            ImPlotNative.ImPlot_MapInputReverse(dst);
        }
        public static void MapInputReverse(ImPlotInputMapPtr dst)
        {
            ImPlotInputMap* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_MapInputReverse(native_dst);
        }
        public static ImPlotTime MkGmtTime(ref Time ptm)
        {
            ImPlotTime __retval;
            fixed (Time* native_ptm = &ptm)
            {
                ImPlotNative.ImPlot_MkGmtTime(&__retval, native_ptm);
                return __retval;
            }
        }
        public static ImPlotTime MkLocTime(ref Time ptm)
        {
            ImPlotTime __retval;
            fixed (Time* native_ptm = &ptm)
            {
                ImPlotNative.ImPlot_MkLocTime(&__retval, native_ptm);
                return __retval;
            }
        }
        public static ImPlotTime MkTime(ref Time ptm)
        {
            ImPlotTime __retval;
            fixed (Time* native_ptm = &ptm)
            {
                ImPlotNative.ImPlot_MkTime(&__retval, native_ptm);
                return __retval;
            }
        }
        public static Vector4 NextColormapColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_NextColormapColor(&__retval);
            return __retval;
        }
        public static uint NextColormapColorU32()
        {
            uint ret = ImPlotNative.ImPlot_NextColormapColorU32();
            return ret;
        }
        public static double NiceNum(double x, bool round)
        {
            byte native_round = round ? (byte)1 : (byte)0;
            double ret = ImPlotNative.ImPlot_NiceNum(x, native_round);
            return ret;
        }
        public static ImPlotTime Now()
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_Now(&__retval);
            return __retval;
        }
        public static int OrderOfMagnitude(double val)
        {
            int ret = ImPlotNative.ImPlot_OrderOfMagnitude(val);
            return ret;
        }
        public static int OrderToPrecision(int order)
        {
            int ret = ImPlotNative.ImPlot_OrderToPrecision(order);
            return ret;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix)
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y)
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBars(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsG(string label_id, ImPlotGetter getter, IntPtr data, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotBarsG(string label_id, ImPlotGetter getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigitalG(string label_id, ImPlotGetter getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotDigitalG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotDummy(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDummyFlags flags = (ImPlotDummyFlags)0;
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotDummy(string label_id, ImPlotDummyFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static void PlotImage(string label_id, ImTextureRef tex_ref, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv0 = new Vector2();
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, tex_ref, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, ImTextureRef tex_ref, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, tex_ref, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, ImTextureRef tex_ref, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, tex_ref, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, ImTextureRef tex_ref, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, tex_ref, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, ImTextureRef tex_ref, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col, ImPlotImageFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotImage(native_label_id, tex_ref, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotInfLines(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLineG(string label_id, ImPlotGetter getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotLineG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ImPlotFormatter fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* fmt_data = null;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ImPlotFormatter fmt, IntPtr fmt_data, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            void* native_fmt_data = (void*)fmt_data.ToPointer();
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrPlotFormatter(native_label_ids, native_values, count, x, y, radius, fmt, native_fmt_data, angle0, flags);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64PtrStr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatterG(string label_id, ImPlotGetter getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotScatterG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShadedG(string label_id, ImPlotGetter getter1, IntPtr data1, ImPlotGetter getter2, IntPtr data2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotShadedG(string label_id, ImPlotGetter getter1, IntPtr data1, ImPlotGetter getter2, IntPtr data2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairsG(string label_id, ImPlotGetter getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotStairsG(string label_id, ImPlotGetter getter, IntPtr data, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotStems(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotText(string text, double x, double y)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            Vector2 pix_offset = new Vector2();
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, Vector2 pix_offset)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, Vector2 pix_offset, ImPlotTextFlags flags)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt)
        {
            Vector2 __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImAxis x_axis)
        {
            Vector2 __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImAxis x_axis, ImAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y)
        {
            Vector2 __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImAxis x_axis)
        {
            Vector2 __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImAxis x_axis, ImAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static void PopColormap()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopColormap(int count)
        {
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopPlotClipRect()
        {
            ImPlotNative.ImPlot_PopPlotClipRect();
        }
        public static void PopStyleColor()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleColor(int count)
        {
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleVar()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PopStyleVar(int count)
        {
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static int Precision(double val)
        {
            int ret = ImPlotNative.ImPlot_Precision(val);
            return ret;
        }
        public static void PushColormap(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_PushColormap_PlotColormap(cmap);
        }
        public static void PushColormap(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotNative.ImPlot_PushColormap_Str(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
        }
        public static void PushPlotClipRect()
        {
            float expand = 0;
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushPlotClipRect(float expand)
        {
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushStyleColor(ImPlotCol idx, uint col)
        {
            ImPlotNative.ImPlot_PushStyleColor_U32(idx, col);
        }
        public static void PushStyleColor(ImPlotCol idx, Vector4 col)
        {
            ImPlotNative.ImPlot_PushStyleColor_Vec4(idx, col);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, float val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Float(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, int val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Int(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, Vector2 val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Vec2(idx, val);
        }
        public static bool RangesOverlap(ImPlotRange r1, ImPlotRange r2)
        {
            byte ret = ImPlotNative.ImPlot_RangesOverlap(r1, r2);
            return ret != 0;
        }
        public static ImPlotItemPtr RegisterOrGetItem(string label_id, ImPlotItemFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* just_created = null;
            ImPlotItem* ret = ImPlotNative.ImPlot_RegisterOrGetItem(native_label_id, flags, just_created);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return new ImPlotItemPtr(ret);
        }
        public static ImPlotItemPtr RegisterOrGetItem(string label_id, ImPlotItemFlags flags, ref bool just_created)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_just_created_val = just_created ? (byte)1 : (byte)0;
            byte* native_just_created = &native_just_created_val;
            ImPlotItem* ret = ImPlotNative.ImPlot_RegisterOrGetItem(native_label_id, flags, native_just_created);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            just_created = native_just_created_val != 0;
            return new ImPlotItemPtr(ret);
        }
        public static void RenderColorBar(ref uint colors, int size, ImDrawListPtr DrawList, ImRect bounds, bool vert, bool reversed, bool continuous)
        {
            ImDrawList* native_DrawList = DrawList.NativePtr;
            byte native_vert = vert ? (byte)1 : (byte)0;
            byte native_reversed = reversed ? (byte)1 : (byte)0;
            byte native_continuous = continuous ? (byte)1 : (byte)0;
            fixed (uint* native_colors = &colors)
            {
                ImPlotNative.ImPlot_RenderColorBar(native_colors, size, native_DrawList, bounds, native_vert, native_reversed, native_continuous);
            }
        }
        public static void ResetCtxForNextAlignedPlots(IntPtr ctx)
        {
            ImPlotNative.ImPlot_ResetCtxForNextAlignedPlots(ctx);
        }
        public static void ResetCtxForNextPlot(IntPtr ctx)
        {
            ImPlotNative.ImPlot_ResetCtxForNextPlot(ctx);
        }
        public static void ResetCtxForNextSubplot(IntPtr ctx)
        {
            ImPlotNative.ImPlot_ResetCtxForNextSubplot(ctx);
        }
        public static ImPlotTime RoundTime(ImPlotTime t, ImPlotTimeUnit unit)
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_RoundTime(&__retval, t, unit);
            return __retval;
        }
        public static double RoundTo(double val, int prec)
        {
            double ret = ImPlotNative.ImPlot_RoundTo(val, prec);
            return ret;
        }
        public static Vector4 SampleColormap(float t)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static Vector4 SampleColormap(float t, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static uint SampleColormapU32(float t, ImPlotColormap cmap)
        {
            uint ret = ImPlotNative.ImPlot_SampleColormapU32(t, cmap);
            return ret;
        }
        public static void SetAxes(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotNative.ImPlot_SetAxes(x_axis, y_axis);
        }
        public static void SetAxis(ImAxis axis)
        {
            ImPlotNative.ImPlot_SetAxis(axis);
        }
        public static void SetCurrentContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetCurrentContext(ctx);
        }
        public static void SetImGuiContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetImGuiContext(ctx);
        }
        public static void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetNextAxesToFit()
        {
            ImPlotNative.ImPlot_SetNextAxesToFit();
        }
        public static void SetNextAxisLimits(ImAxis axis, double v_min, double v_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetNextAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetNextAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetNextAxisLinks(ImAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* native_link_min = &link_min)
            {
                fixed (double* native_link_max = &link_max)
                {
                    ImPlotNative.ImPlot_SetNextAxisLinks(axis, native_link_min, native_link_max);
                }
            }
        }
        public static void SetNextAxisToFit(ImAxis axis)
        {
            ImPlotNative.ImPlot_SetNextAxisToFit(axis);
        }
        public static void SetNextErrorBarStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col)
        {
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size, float weight)
        {
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextFillStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col)
        {
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col, float alpha_mod)
        {
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextLineStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col, float weight)
        {
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextMarkerStyle()
        {
            ImPlotMarker marker = (ImPlotMarker)(-1);
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker)
        {
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size)
        {
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill)
        {
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight)
        {
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight, Vector4 outline)
        {
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetupAxes(string x_label, string y_label)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags x_flags = (ImPlotAxisFlags)0;
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
        public static void SetupAxes(string x_label, string y_label, ImPlotAxisFlags x_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
        public static void SetupAxes(string x_label, string y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
        public static void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetupAxis(ImAxis axis)
        {
            byte* native_label = null;
            ImPlotAxisFlags flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
        }
        public static void SetupAxis(ImAxis axis, string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotAxisFlags flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
        public static void SetupAxis(ImAxis axis, string label, ImPlotAxisFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
        public static void SetupAxisFormat(ImAxis axis, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_SetupAxisFormat_Str(axis, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void SetupAxisFormat(ImAxis axis, ImPlotFormatter formatter)
        {
            void* data = null;
            ImPlotNative.ImPlot_SetupAxisFormat_PlotFormatter(axis, formatter, data);
        }
        public static void SetupAxisFormat(ImAxis axis, ImPlotFormatter formatter, IntPtr data)
        {
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_SetupAxisFormat_PlotFormatter(axis, formatter, native_data);
        }
        public static void SetupAxisLimits(ImAxis axis, double v_min, double v_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetupAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetupAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetupAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetupAxisLimitsConstraints(ImAxis axis, double v_min, double v_max)
        {
            ImPlotNative.ImPlot_SetupAxisLimitsConstraints(axis, v_min, v_max);
        }
        public static void SetupAxisLinks(ImAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* native_link_min = &link_min)
            {
                fixed (double* native_link_max = &link_max)
                {
                    ImPlotNative.ImPlot_SetupAxisLinks(axis, native_link_min, native_link_max);
                }
            }
        }
        public static void SetupAxisScale(ImAxis axis, ImPlotScale scale)
        {
            ImPlotNative.ImPlot_SetupAxisScale_PlotScale(axis, scale);
        }
        public static void SetupAxisScale(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse)
        {
            void* data = null;
            ImPlotNative.ImPlot_SetupAxisScale_PlotTransform(axis, forward, inverse, data);
        }
        public static void SetupAxisScale(ImAxis axis, ImPlotTransform forward, ImPlotTransform inverse, IntPtr data)
        {
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_SetupAxisScale_PlotTransform(axis, forward, inverse, native_data);
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, labels, keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, native_labels, keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, native_labels, native_keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, labels, keep_default);
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, native_labels, keep_default);
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, native_labels, native_keep_default);
        }
        public static void SetupAxisZoomConstraints(ImAxis axis, double z_min, double z_max)
        {
            ImPlotNative.ImPlot_SetupAxisZoomConstraints(axis, z_min, z_max);
        }
        public static void SetupFinish()
        {
            ImPlotNative.ImPlot_SetupFinish();
        }
        public static void SetupLegend(ImPlotLocation location)
        {
            ImPlotLegendFlags flags = (ImPlotLegendFlags)0;
            ImPlotNative.ImPlot_SetupLegend(location, flags);
        }
        public static void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags)
        {
            ImPlotNative.ImPlot_SetupLegend(location, flags);
        }
        public static void SetupLock()
        {
            ImPlotNative.ImPlot_SetupLock();
        }
        public static void SetupMouseText(ImPlotLocation location)
        {
            ImPlotMouseTextFlags flags = (ImPlotMouseTextFlags)0;
            ImPlotNative.ImPlot_SetupMouseText(location, flags);
        }
        public static void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags)
        {
            ImPlotNative.ImPlot_SetupMouseText(location, flags);
        }
        public static void ShowAltLegend(string title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte vertical = 1;
            Vector2 size = new Vector2();
            byte interactable = 1;
            ImPlotNative.ImPlot_ShowAltLegend(native_title_id, vertical, size, interactable);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
        }
        public static void ShowAltLegend(string title_id, bool vertical)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            Vector2 size = new Vector2();
            byte interactable = 1;
            ImPlotNative.ImPlot_ShowAltLegend(native_title_id, native_vertical, size, interactable);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
        }
        public static void ShowAltLegend(string title_id, bool vertical, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            byte interactable = 1;
            ImPlotNative.ImPlot_ShowAltLegend(native_title_id, native_vertical, size, interactable);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
        }
        public static void ShowAltLegend(string title_id, bool vertical, Vector2 size, bool interactable)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            byte native_interactable = interactable ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_ShowAltLegend(native_title_id, native_vertical, size, native_interactable);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
        }
        public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ImPlotAxisPtr equal_axis)
        {
            ImPlotAxis* native_axis = axis.NativePtr;
            ImPlotAxis* native_equal_axis = equal_axis.NativePtr;
            byte time_allowed = 0;
            ImPlotNative.ImPlot_ShowAxisContextMenu(native_axis, native_equal_axis, time_allowed);
        }
        public static void ShowAxisContextMenu(ImPlotAxisPtr axis, ImPlotAxisPtr equal_axis, bool time_allowed)
        {
            ImPlotAxis* native_axis = axis.NativePtr;
            ImPlotAxis* native_equal_axis = equal_axis.NativePtr;
            byte native_time_allowed = time_allowed ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_ShowAxisContextMenu(native_axis, native_equal_axis, native_time_allowed);
        }
        public static bool ShowColormapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowColormapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            ImPlotTime* native_t = t.NativePtr;
            ImPlotTime* t1 = null;
            ImPlotTime* t2 = null;
            fixed (int* native_level = &level)
            {
                byte ret = ImPlotNative.ImPlot_ShowDatePicker(native_id, native_level, native_t, t1, t2);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            ImPlotTime* native_t = t.NativePtr;
            ImPlotTime* native_t1 = t1.NativePtr;
            ImPlotTime* t2 = null;
            fixed (int* native_level = &level)
            {
                byte ret = ImPlotNative.ImPlot_ShowDatePicker(native_id, native_level, native_t, native_t1, t2);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            ImPlotTime* native_t = t.NativePtr;
            ImPlotTime* native_t1 = t1.NativePtr;
            ImPlotTime* native_t2 = t2.NativePtr;
            fixed (int* native_level = &level)
            {
                byte ret = ImPlotNative.ImPlot_ShowDatePicker(native_id, native_level, native_t, native_t1, native_t2);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static void ShowDemoWindow()
        {
            byte* p_open = null;
            ImPlotNative.ImPlot_ShowDemoWindow(p_open);
        }
        public static void ShowDemoWindow(ref bool p_open)
        {
            byte native_p_open_val = p_open ? (byte)1 : (byte)0;
            byte* native_p_open = &native_p_open_val;
            ImPlotNative.ImPlot_ShowDemoWindow(native_p_open);
            p_open = native_p_open_val != 0;
        }
        public static bool ShowInputMapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowInputMapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ShowLegendContextMenu(ImPlotLegendPtr legend, bool visible)
        {
            ImPlotLegend* native_legend = legend.NativePtr;
            byte native_visible = visible ? (byte)1 : (byte)0;
            byte ret = ImPlotNative.ImPlot_ShowLegendContextMenu(native_legend, native_visible);
            return ret != 0;
        }
        public static bool ShowLegendEntries(ImPlotItemGroupPtr items, ImRect legend_bb, bool interactable, Vector2 pad, Vector2 spacing, bool vertical, ImDrawListPtr DrawList)
        {
            ImPlotItemGroup* native_items = items.NativePtr;
            byte native_interactable = interactable ? (byte)1 : (byte)0;
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            ImDrawList* native_DrawList = DrawList.NativePtr;
            byte ret = ImPlotNative.ImPlot_ShowLegendEntries(native_items, legend_bb, native_interactable, pad, spacing, native_vertical, native_DrawList);
            return ret != 0;
        }
        public static void ShowMetricsWindow()
        {
            byte* p_popen = null;
            ImPlotNative.ImPlot_ShowMetricsWindow(p_popen);
        }
        public static void ShowMetricsWindow(ref bool p_popen)
        {
            byte native_p_popen_val = p_popen ? (byte)1 : (byte)0;
            byte* native_p_popen = &native_p_popen_val;
            ImPlotNative.ImPlot_ShowMetricsWindow(native_p_popen);
            p_popen = native_p_popen_val != 0;
        }
        public static void ShowPlotContextMenu(ImPlotPlotPtr plot)
        {
            ImPlotPlot* native_plot = plot.NativePtr;
            ImPlotNative.ImPlot_ShowPlotContextMenu(native_plot);
        }
        public static void ShowStyleEditor()
        {
            ImPlotStyle* @ref = null;
            ImPlotNative.ImPlot_ShowStyleEditor(@ref);
        }
        public static void ShowStyleEditor(ImPlotStylePtr @ref)
        {
            ImPlotStyle* native_ref = @ref.NativePtr;
            ImPlotNative.ImPlot_ShowStyleEditor(native_ref);
        }
        public static bool ShowStyleSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowStyleSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowSubplotsContextMenu(ImPlotSubplotPtr subplot)
        {
            ImPlotSubplot* native_subplot = subplot.NativePtr;
            ImPlotNative.ImPlot_ShowSubplotsContextMenu(native_subplot);
        }
        public static bool ShowTimePicker(string id, ImPlotTimePtr t)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            ImPlotTime* native_t = t.NativePtr;
            byte ret = ImPlotNative.ImPlot_ShowTimePicker(native_id, native_t);
            if (id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_id);
            }
            return ret != 0;
        }
        public static void ShowUserGuide()
        {
            ImPlotNative.ImPlot_ShowUserGuide();
        }
        public static void StyleColorsAuto()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsAuto(dst);
        }
        public static void StyleColorsAuto(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsAuto(native_dst);
        }
        public static void StyleColorsClassic()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsClassic(dst);
        }
        public static void StyleColorsClassic(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsClassic(native_dst);
        }
        public static void StyleColorsDark()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsDark(dst);
        }
        public static void StyleColorsDark(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsDark(native_dst);
        }
        public static void StyleColorsLight()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsLight(dst);
        }
        public static void StyleColorsLight(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsLight(native_dst);
        }
        public static void SubplotNextCell()
        {
            ImPlotNative.ImPlot_SubplotNextCell();
        }
        public static void TagX(double x, Vector4 col)
        {
            byte round = 0;
            ImPlotNative.ImPlot_TagX_Bool(x, col, round);
        }
        public static void TagX(double x, Vector4 col, bool round)
        {
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_TagX_Bool(x, col, native_round);
        }
        public static void TagX(double x, Vector4 col, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagX_Str(x, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void TagY(double y, Vector4 col)
        {
            byte round = 0;
            ImPlotNative.ImPlot_TagY_Bool(y, col, round);
        }
        public static void TagY(double y, Vector4 col, bool round)
        {
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_TagY_Bool(y, col, native_round);
        }
        public static void TagY(double y, Vector4 col, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagY_Str(y, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static ImPlotTime Today()
        {
            ImPlotTime __retval;
            ImPlotNative.ImPlot_Today(&__retval);
            return __retval;
        }
        public static double TransformForward_Log10(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformForward_Log10(v, native_noname1);
            return ret;
        }
        public static double TransformForward_Logit(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformForward_Logit(v, native_noname1);
            return ret;
        }
        public static double TransformForward_SymLog(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformForward_SymLog(v, native_noname1);
            return ret;
        }
        public static double TransformInverse_Log10(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformInverse_Log10(v, native_noname1);
            return ret;
        }
        public static double TransformInverse_Logit(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformInverse_Logit(v, native_noname1);
            return ret;
        }
        public static double TransformInverse_SymLog(double v, IntPtr noname1)
        {
            void* native_noname1 = (void*)noname1.ToPointer();
            double ret = ImPlotNative.ImPlot_TransformInverse_SymLog(v, native_noname1);
            return ret;
        }
    }
}
